<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="rest-template" 
    xmlns="http://docbook.org/ns/docbook" version="5.0"
    xmlns:xl="http://www.w3.org/1999/xlink"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd
        http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd">

 <title>RestTemplate Module</title>

  <section id="rest-template-introduction">
	
	<title>Introduction</title>
	
	<para>Spring's RestTemplate is a robust, popular Java-based REST client. The Spring for Android RestTemplate Module provides a version of RestTemplate that works in an Android environment.</para>
	
  </section>

  <section id="rest-template-overview">
	
	<title>Overview</title>	
	
	<para>The <classname>RestTemplate</classname> class is the heart of the Spring for Android RestTemplate library. It is conceptually similar to other template classes found in other Spring portfolio projects. RestTemplate's behavior is customized by providing callback methods and configuring the <interfacename>HttpMessageConverter</interfacename> used to marshal objects into the HTTP request body and to unmarshal any response back into an object. When you create a new <classname>RestTemplate</classname> instance, the constructor sets up several supporting objects that make up the RestTemplate functionality.</para>

	<para>Here is an overview of the functionality supported within <classname>RestTemplate</classname>.</para>

	<section>
		
		<title>HTTP Client</title>
		
		<para><classname>RestTemplate</classname> provides an abstraction for making RESTful HTTP requests, and internally, <classname>RestTemplate</classname> utilizes a native Android HTTP client library for those requests. There are two native HTTP clients available on Android, the standard J2SE facilities, and the <ulink url="http://hc.apache.org/httpcomponents-client-ga/index.html"><citetitle>HttpComponents HttpClient</citetitle></ulink>. The standard JS2SE facilities are made available through <classname>SimpleClientHttpRequestFactory</classname>, while the HttpClient can be utilized via <classname>HttpComponentsAndroidClientHttpRequestFactory</classname>. Support for native HttpClient 4.0 is deprecated in favor of the Android port of HttpClient 4.3. The default <interfacename>ClientHttpRequestFactory</interfacename> used when you create a new <classname>RestTemplate</classname> instance differs based on the version of Android on which your application is running.</para>

		<para>Google recommends to use the J2SE facilities on <ulink url="http://android-developers.blogspot.com/2011/09/androids-http-clients.html"><citetitle>Android 2.3 (Gingerbread)</citetitle></ulink> and newer, while previous versions should use the HttpComponents HttpClient. Based on this recommendation <classname>RestTemplate</classname> checks the version of Android on which your app is running and uses the appropriate <interfacename>ClientHttpRequestFactory</interfacename>. To utilize a specific <interfacename>ClientHttpRequestFactory</interfacename> you must either pass a new instance into the <classname>RestTemplate</classname> constructor, or call <methodname>setRequestFactory(ClientHttpRequestFactory requestFactory)</methodname> on an existing <classname>RestTemplate</classname> instance.</para>

		<para>Spring for Android also includes support for third-party HTTP client libraries. <ulink url="http://hc.apache.org/httpcomponents-client-4.3.x/android-port.html">HttpClient 4.3 for Android</ulink> is compatible with all versions of Android, and may be utilized as an alternative to the native clients by simply including the dependency in your project. If Spring for Android detects HttpClient 4.3, then it will automatically configure it as the default <interfacename>ClientHttpRequestFactory</interfacename>. HttpClient 4.3 has a considerable number of bug fixes and improvements over the native HttpClient 4.0 included within Android.

			<programlisting language="groovy"><![CDATA[
dependencies {
    compile('org.apache.httpcomponents:httpclient-android:$httpClientVersion')
}]]>
			</programlisting>

		</para>

		<para>An additional <interfacename>ClientHttpRequestFactory</interfacename> based on <ulink url="https://square.github.io/okhttp/"><citetitle>OkHttp</citetitle></ulink> is available as an alternative to the two native clients. <classname>RestTemplate</classname> can be configured to use <classname>OkHttpRequestFactory</classname> through the <classname>RestTemplate</classname> constructor or by setting the <literal>requestFactory</literal> property. It is supported on Android 2.3 (Gingerbread) and newer, however in order to use it, you must include the OkHttp dependency in your project.

			<programlisting language="groovy"><![CDATA[
dependencies {
    compile('com.squareup.okhttp:okhttp-urlconnection:$okHttpVersion')
}]]>
			</programlisting>

		</para>

	</section>

	<section>
		
		<title>Gzip Compression</title>
		
		<para><classname>RestTemplate</classname> supports sending and receiving data encoded with gzip compression. The HTTP specification allows for additional values in the <literal>Accept-Encoding</literal> header field, however <classname>RestTemplate</classname> only supports gzip compression at this time.</para>
		
	</section>
	
	<section>
		
		<title>Object to JSON Marshaling</title>
		
		<para>Object to JSON marshaling in Spring for Android RestTemplate requires the use of a third party JSON mapping library. There are two libraries supported in Spring for Android, <ulink url="https://github.com/FasterXML/jackson-databind"><citetitle>Jackson 2.x</citetitle></ulink> and <ulink url="http://code.google.com/p/google-gson/"><citetitle>Google Gson</citetitle></ulink>. While Jackson is a well known JSON parsing library, the Gson library is smaller, which would result in an smaller Android app when packaged.</para>
		
	</section>
	
	<section>
		
		<title>Object to XML Marshaling</title>
		
		<para>Object to XML marshaling in Spring for Android RestTemplate requires the use of a third party XML mapping library. The <ulink url="http://simple.sourceforge.net">
 	<citetitle>Simple XML serializer</citetitle></ulink> is used to provide this marshaling functionality.</para>
		
	</section>
	
  </section>

  <section id="rest-template-howtoget">

	<title>How to get</title>

	<para>There are a few methods for including external jars in your Android app. You can use Gradle or Maven for dependency management, or manually download them and include them in your app's <literal>libs/</literal> folder.</para>

	<section>

		<title>Gradle</title>

		<para><ulink url="https://developer.android.com/sdk/installing/studio.html">Android Studio</ulink> and the <ulink url="http://tools.android.com/tech-docs/new-build-system">New Build System</ulink> for Android offer a Gradle plugin for building Android apps. Gradle provides built in dependency management, which can be used to include the Spring for Android dependencies in your project.</para>

		<para>Add the spring-android-rest-template dependency to your <literal>build.gradle</literal> file:

			<programlisting language="groovy"><![CDATA[
dependencies {
    compile('org.springframework.android:spring-android-rest-template:${version}')
}]]>
			</programlisting>

		</para>

	</section>

	<section>

		<title>Maven</title>

		<para>Maven can be used to manage dependencies and build your Android app. See the <link linkend="spring-android-maven">Spring for Android and Maven</link> section for more information. Additional dependencies may be required, depending on which HTTP Message Converters you are using within RestTemplate. See the <link linkend="rest-template-message-converters">Message Converters</link> section for more information.</para>

		<para>Add the spring-android-rest-template dependency to your <literal>pom.xml</literal> file:

			<programlisting language="xml"><![CDATA[
<dependency>
    <groupId>org.springframework.android</groupId>
    <artifactId>spring-android-rest-template</artifactId>
    <version>${spring-android-version}</version>
</dependency>]]>
			</programlisting>

		</para>

	</section>

	<section>

		<title>Ant and Eclipse</title>

		<para>In order to use RestTemplate in your Android application, you must include the following Spring for Android jars in the <literal>libs/</literal> folder.

			<itemizedlist>
				<listitem><literal>spring-android-rest-template-{version}.jar</literal></listitem>
				<listitem><literal>spring-android-core-{version}.jar</literal></listitem>
			</itemizedlist>

		</para>

		<para>If you are building your project with Ant, Ant will automatically include any jars located in the <literal>libs/</literal> folder located in the root of your project. However, in Eclipse you must manually add the jars to the Build Path. Follow these steps to add the jars to your existing Android project in Eclipse.

		<orderedlist>
			<listitem>Refresh the project in Eclipse so the <literal>libs/</literal> folder and jars display in the Package Explorer.</listitem>
			<listitem>Right-Click (Command-Click) the first jar.</listitem>
			<listitem>Select the <literal>BuildPath</literal> submenu.</listitem>
			<listitem>Select <literal>Add to Build Path</literal> from the context menu.</listitem>
			<listitem>Repeat these steps for each jar.</listitem>
		</orderedlist>

		</para>

	</section>

  </section>

  <section id="rest-template-constructors">
	
	<title>RestTemplate Constructors</title>
	
	<para>The <classname>RestTemplate</classname> constructors are listed below. The default constructor includes a standard set of message body converters. For a list of default converters, see the <link linkend="rest-template-message-converters">HTTP Message Conversion</link> section.
	
		<programlisting language="java"><![CDATA[
RestTemplate();

RestTemplate(ClientHttpRequestFactory requestFactory);

RestTemplate(List<HttpMessageConverter<?>> messageConverters);]]>
		</programlisting>
	
	</para>

	<para>If you would like to specify an alternate <interfacename>ClientHttpRequestFactory</interfacename>, such as <classname>OkHttpClientHttpRequestFactory</classname>, then you can do so by passing it in to the <literal>requestFactory</literal> parameter.
		<programlisting language="java"><![CDATA[
OkHttpClientHttpRequestFactory requestFactory = new OkHttpClientHttpRequestFactory();
RestTemplate template = new RestTemplate(ClientHttpRequestFactory requestFactory);]]>
		</programlisting>
	</para>

  </section>

  <section id="rest-template-methods">
		
	<title>RestTemplate Methods</title>
	
	<para><classname>RestTemplate</classname> provides higher level methods that correspond to each of the six main HTTP methods. These methods make it easy to invoke many RESTful services and enforce REST best practices.</para>
	
	<para>The names of <classname>RestTemplate</classname> methods follow a naming convention, the first part indicates what HTTP method is being invoked and the second part indicates what is returned. For example, the method <methodname>getForObject()</methodname> will perform a GET, convert the HTTP response into an object type of your choice and return that object. The method <methodname>postForLocation()</methodname> will do a POST, converting the given object into a HTTP request and return the response HTTP Location header where the newly created object can be found. In case of an exception processing the HTTP request, an exception of the type <classname>RestClientException</classname> will be thrown.  This behavior can be changed by plugging in another <interfacename>ResponseErrorHandler</interfacename> implementation into the <classname>RestTemplate.</classname></para>
	
	<para>For more information on <classname>RestTemplate</classname> and it's associated methods, please refer to the <ulink url="http://docs.spring.io/spring-android/docs/2.0.x/api/org/springframework/web/client/RestTemplate.html">
 	<citetitle>API Javadoc</citetitle></ulink></para>
	
	<section>
		
		<title>HTTP DELETE</title>
		
		<programlisting language="java"><![CDATA[
public void delete(String url, Object... urlVariables) throws RestClientException;

public void delete(String url, Map<String, ?> urlVariables) throws RestClientException;

public void delete(URI url) throws RestClientException;]]>
		</programlisting>

	</section>

	<section>
		
		<title>HTTP GET</title>

		<programlisting language="java"><![CDATA[
public <T> T getForObject(String url, Class<T> responseType, Object... urlVariables) throws RestClientException;

public <T> T getForObject(String url, Class<T> responseType, Map<String, ?> urlVariables) throws RestClientException;

public <T> T getForObject(URI url, Class<T> responseType) throws RestClientException;

public <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... urlVariables);

public <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> urlVariables);

public <T> ResponseEntity<T> getForEntity(URI url, Class<T> responseType) throws RestClientException;]]>
		</programlisting>
		
	</section>

	<section>

		<title>HTTP HEAD</title>

		<programlisting language="java"><![CDATA[
public HttpHeaders headForHeaders(String url, Object... urlVariables) throws RestClientException;

public HttpHeaders headForHeaders(String url, Map<String, ?> urlVariables) throws RestClientException;

public HttpHeaders headForHeaders(URI url) throws RestClientException;]]>
		</programlisting>

	</section>
	
	<section>

		<title>HTTP OPTIONS</title>

		<programlisting language="java"><![CDATA[
public Set<HttpMethod> optionsForAllow(String url, Object... urlVariables) throws RestClientException;

public Set<HttpMethod> optionsForAllow(String url, Map<String, ?> urlVariables) throws RestClientException;

public Set<HttpMethod> optionsForAllow(URI url) throws RestClientException;]]>
		</programlisting>

	</section>
	
	<section>

		<title>HTTP POST</title>

		<programlisting language="java"><![CDATA[
public URI postForLocation(String url, Object request, Object... urlVariables) throws RestClientException;

public URI postForLocation(String url, Object request, Map<String, ?> urlVariables);

public URI postForLocation(URI url, Object request) throws RestClientException;

public <T> T postForObject(String url, Object request, Class<T> responseType, Object... uriVariables);

public <T> T postForObject(String url, Object request, Class<T> responseType, Map<String, ?> uriVariables);

public <T> T postForObject(URI url, Object request, Class<T> responseType) throws RestClientException;

public <T> ResponseEntity<T> postForEntity(String url, Object request, Class<T> responseType, Object... uriVariables);

public <T> ResponseEntity<T> postForEntity(String url, Object request, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException;

public <T> ResponseEntity<T> postForEntity(URI url, Object request, Class<T> responseType) throws RestClientException;]]>
		</programlisting>

	</section>
	
	<section>

		<title>HTTP PUT</title>

		<programlisting language="java"><![CDATA[
public void put(String url, Object request, Object... urlVariables) throws RestClientException;

public void put(String url, Object request, Map<String, ?> urlVariables) throws RestClientException;

public void put(String url, Object request, Map<String, ?> urlVariables) throws RestClientException;]]>
		</programlisting>

	</section>
	
  </section>

  <section id="rest-template-message-converters">

	<title>HTTP Message Conversion</title>

	<para>Objects passed to and returned from the methods <methodname>getForObject()</methodname>, <methodname>getForEntity()</methodname>, <methodname>postForLocation()</methodname>, <methodname>postForObject()</methodname> and <methodname>put()</methodname> are converted to HTTP requests and from HTTP responses by <interfacename>HttpMessageConverter</interfacename> instances. The <interfacename>HttpMessageConverter</interfacename> interface is shown below to give you a better feel for its functionality.</para>

	<programlisting language="java"><![CDATA[
public interface HttpMessageConverter<T> {

    // Indicates whether the given class can be read by this converter.
    boolean canRead(Class<?> clazz, MediaType mediaType);

    // Indicates whether the given class can be written by this converter.
    boolean canWrite(Class<?> clazz, MediaType mediaType);

    // Return the list of {@link MediaType} objects supported by this converter.
    List<MediaType> getSupportedMediaTypes();

    // Read an object of the given type form the given input message, and returns it.
    T read(Class<? extends T> clazz, HttpInputMessage inputMessage)
            throws IOException, HttpMessageNotReadableException;

    // Write an given object to the given output message.
    void write(T t, MediaType contentType, HttpOutputMessage outputMessage)
            throws IOException, HttpMessageNotWritableException;

}]]>
	</programlisting>	

	<para>Concrete implementations for the main media (mime) types are provided in the framework.</para>
	
	<section>
		
		<title>Default Message Converters</title>
	
		<para>The default <classname>RestTemplate</classname> constructor registers a standard set of message converters for the main mime types. You can also write your own converter and register it via the <methodname>messageConverters</methodname> property.</para>
		
		<para>The default converter instances registered with the template are <classname>ByteArrayHttpMessageConverter</classname>, <classname>StringHttpMessageConverter</classname>, <classname>ResourceHttpMessageConverter</classname>, <classname>SourceHttpMessageConverter</classname> and <classname>AllEncompassingFormHttpMessageConverter</classname>. See the following table for more information.</para>
	
		<table border="1" cellpadding="2" cellspacing="0" align="center">
			<caption>Default Message Converters</caption>
			<thead>
				<tr><th>Message Body Converter</th><th>Inclusion Rule</th></tr>
			</thead>
			<tbody>
				<tr><td><link linkend="ByteArrayHttpMessageConverter"><classname>ByteArrayHttpMessageConverter</classname></link></td><td rowspan="5" valign="top">Always included</td></tr>
				<tr><td><link linkend="StringHttpMessageConverter"><classname>StringHttpMessageConverter</classname></link></td></tr>
				<tr><td><link linkend="ResourceHttpMessageConverter"><classname>ResourceHttpMessageConverter</classname></link></td></tr>
				<tr><td><link linkend="SourceHttpMessageConverter"><classname>SourceHttpMessageConverter</classname></link></td></tr>
				<tr><td><link linkend="AllEncompassingFormHttpMessageConverter"><classname>AllEncompassingFormHttpMessageConverter</classname></link></td></tr>
				<tr><td><link linkend="SimpleXmlHttpMessageConverter"><classname>SimpleXmlHttpMessageConverter</classname></link></td><td>Included if the Simple XML serializer is present.</td></tr>
				<tr><td><link linkend="MappingJackson2HttpMessageConverter"><classname>MappingJackson2HttpMessageConverter</classname></link></td><td>Included if the Jackson 2.x JSON processor is present.</td></tr>
				<tr><td><link linkend="GsonHttpMessageConverter"><classname>GsonHttpMessageConverter</classname></link></td><td>Included if Gson is present. Jackson 2.x takes precedence over Gson if both are available on the classpath.</td></tr>
			</tbody>
		</table>
	
	</section>

	<section>
		
		<title>Available Message Converters</title>
		
	<para>The following <interfacename>HttpMessageConverter</interfacename> implementations are available in Spring for Android. For all converters a default media type is used but can be overridden through the <methodname>supportedMediaTypes</methodname> property.</para>

	<section id="ByteArrayHttpMessageConverter">

		<title>ByteArrayHttpMessageConverter</title>

		<para>An <interfacename>HttpMessageConverter</interfacename> implementation that can read and write byte arrays from the HTTP request and response. By default, this converter supports all media types (<literal>*/*</literal>), and writes with a <literal>Content-Type</literal> of <literal>application/octet-stream</literal>. This can be overridden by setting the supportedMediaTypes property, and overriding <methodname>getContentType(byte[])</methodname>.</para>

	</section>
	
	<section id="FormHttpMessageConverter">

		<title>FormHttpMessageConverter</title>

		<para>An <interfacename>HttpMessageConverter</interfacename> implementation that can read and write form data from the HTTP request and response. By default, this converter reads and writes the media type <literal>application/x-www-form-urlencoded</literal>. Form data is read from and written into a <literal>MultiValueMap&lt;String, String&gt;</literal>.</para>

	</section>
	
	<section id="AllEncompassingFormHttpMessageConverter">

		<title>AllEncompassingFormHttpMessageConverter</title>

		<para>Extension of <classname>FormHttpMessageConverter</classname>, adding support for XML and JSON-based parts.</para>

	</section>
	
	<section id="ResourceHttpMessageConverter">

		<title>ResourceHttpMessageConverter</title>

		<para>An <interfacename>HttpMessageConverter</interfacename> implementation that can read and write <interfacename>Resource</interfacename> Resources. By default, this converter can read all media types. Written resources use <literal>application/octet-stream</literal> for the <classname>Content-Type</classname>.</para>

	</section>
	
	<section id="SourceHttpMessageConverter">

		<title>SourceHttpMessageConverter</title>

		<para>An <interfacename>HttpMessageConverter</interfacename> implementation that can read and write <classname>javax.xml.transform.Source</classname> from the HTTP request and response. Only <classname>DOMSource</classname>, <classname>SAXSource</classname>, and <classname>StreamSource</classname> are supported. By default, this converter supports <literal>text/xml</literal> and <literal>application/xml</literal>.</para>

	</section>

	<section id="StringHttpMessageConverter">

		<title>StringHttpMessageConverter</title>

		<para>An <interfacename>HttpMessageConverter</interfacename> implementation that can read and write Strings from the HTTP request and response. By default, this converter supports all text media types (<literal>text/*</literal>), and writes with a <literal>Content-Type</literal> of <literal>text/plain</literal>.</para>

	</section>

	<section id="SimpleXmlHttpMessageConverter">

		<title>SimpleXmlHttpMessageConverter</title>

		<para>An <interfacename>HttpMessageConverter</interfacename> implementation that can read and write XML from the HTTP request and response using <ulink url="http://simple.sourceforge.net">
 	<citetitle>Simple Framework</citetitle></ulink>'s <interfacename>Serializer</interfacename>. XML mapping can be customized as needed through the use of Simple's provided annotations. When additional control is needed, a custom <interfacename>Serializer</interfacename> can be injected through the <interfacename>Serializer</interfacename> property. By default, this converter reads and writes the media types <literal>application/xml</literal>, <literal>text/xml</literal>, and <literal>application/*+xml</literal>.</para>

		<para>It is important to note that this is not a Spring OXM compatible message converter. It is a standalone implementation that enables XML serialization through Spring for Android.</para>
		
		<para>Add the following dependency to your classpath to enable the <classname>SimpleXmlHttpMessageConverter</classname>.
		
			<para>Gradle:</para>
			<programlisting language="groovy"><![CDATA[
dependencies {
    compile('org.simpleframework:simple-xml:${version}')
}]]>
			</programlisting>

			<para>Maven:</para>
			<programlisting language="xml"><![CDATA[
<dependency>
    <groupId>org.simpleframework</groupId>
    <artifactId>simple-xml</artifactId>
    <version>${simple-version}</version>
</dependency>]]>
			</programlisting>
		
		</para>

	</section>

	<section id="MappingJackson2HttpMessageConverter">

		<title>MappingJackson2HttpMessageConverter</title>

		<para>An <interfacename>HttpMessageConverter</interfacename> implementation that can read and write JSON using <ulink url="https://github.com/FasterXML/jackson-databind">
 	<citetitle>Jackson (2.x)</citetitle></ulink>'s <classname>ObjectMapper</classname>. JSON mapping can be customized as needed through the use of Jackson's provided annotations. When further control is needed, a custom <classname>ObjectMapper</classname> can be injected through the <classname>ObjectMapper</classname> property for cases where custom JSON serializers/deserializers need to be provided for specific types. By default this converter supports <literal>application/json</literal>.</para>
		
		<para>Please note that this message converter and the <classname>GsonHttpMessageConverter</classname> both support <literal>application/json</literal> by default. Because of this, you should only add one JSON message converter to a <classname>RestTemplate</classname> instance. <classname>RestTemplate</classname> will use the first converter it finds that matches the specified mime type, so including both could produce unintended results.</para>
		
		<para>Include the following dependencies in your classpath to enable the <classname>MappingJackson2HttpMessageConverter</classname>. Please note that if you are manually copying the jars into your project, you will also need to include the <literal>jackson-annotations</literal> and <literal>jackson-core</literal> jars.

			<para>Gradle:</para>
			<programlisting language="groovy"><![CDATA[
dependencies {
    compile('com.fasterxml.jackson.core:jackson-databind:${version}')
}]]>
			</programlisting>

			<para>Maven:</para>
			<programlisting language="xml"><![CDATA[
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>${jackson-version}</version>
</dependency>]]>
			</programlisting>
			
		</para>

	</section>

	<section id="GsonHttpMessageConverter">

		<title>GsonHttpMessageConverter</title>

		<para>An <interfacename>HttpMessageConverter</interfacename> implementation that can read and write JSON using <ulink url="http://code.google.com/p/google-gson/">
 	<citetitle>Google Gson</citetitle></ulink>'s <classname>Gson</classname> class. JSON mapping can be customized as needed through the use of Gson's provided annotations. When further control is needed, a custom <classname>Gson</classname> can be injected through the <classname>Gson</classname> property for cases where custom JSON serializers/deserializers need to be provided for specific types. By default this converter supports <literal>application/json</literal>.</para>

		<para>Please note that this message converter and the <classname>MappingJackson2HttpMessageConverter</classname> both support <literal>application/json</literal> by default. Because of this, you should only add one JSON message converter to a <classname>RestTemplate</classname> instance. <classname>RestTemplate</classname> will use the first converter it finds that matches the specified mime type, so including both could produce unintended results.</para>

		<para>Include the following dependency in your classpath to enable the <classname>GsonHttpMessageConverter</classname>.

			<para>Gradle:</para>
			<programlisting language="groovy"><![CDATA[
dependencies {
    compile('com.google.code.gson:gson:${version}')
}]]>
			</programlisting>

			<para>Maven:</para>
			<programlisting language="xml"><![CDATA[
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>${gson-version}</version>
</dependency>]]>
			</programlisting>

		</para>
	
	</section>

	</section>

  </section>

  <section id="rest-template-examples">
	
  	<title>Usage Examples</title>

  	<para>Using <classname>RestTemplate</classname>, it is easy to invoke RESTful APIs. Below are several usage examples that illustrate the different methods for making RESTful requests.</para>
	
	<para>All of the following examples are based on a <ulink url="https://github.com/spring-projects/spring-android-samples">
 	<citetitle>sample Android application</citetitle></ulink>. You can retrieve the source code for the sample app with the following command:</para>
	
	<programlisting>
$ git clone git://github.com/spring-projects/spring-android-samples.git
	</programlisting>	

  	<section>
	
		<title>Basic Usage Example</title>
		
		<para>The following example shows a query to google for the search term "Spring Framework".</para>
		
		<programlisting language="java"><![CDATA[
String url = "https://ajax.googleapis.com/ajax/services/search/web?v=1.0&q={query}";
			
// Create a new RestTemplate instance
RestTemplate restTemplate = new RestTemplate();

// Make the HTTP GET request, marshaling the response to a String
String result = restTemplate.getForObject(url, String.class, "Spring Framework");]]>
		</programlisting>
		
	</section>
	
  	<section>

		<title>Using Gzip Compression</title>

		<para>Gzip compression can significantly reduce the size of the response data being returned in a REST request. Gzip must be supported by the web server to which the request is being made. By setting the content coding type of the <literal>Accept-Encoding</literal> header to <literal>gzip</literal>, you are requesting that the server respond using gzip compression. If gzip is available, or enabled on the server, then it should return a compressed response. RestTemplate checks the <literal>Content-Encoding</literal> header in the response to determine if, in fact, the response is gzip compressed. At this time, RestTemplate only supports the gzip content coding type in the <literal>Content-Encoding</literal> header. If the response data is determined to be gzip compressed, then a <ulink url="http://developer.android.com/reference/java/util/zip/GZIPInputStream.html">
 	<citetitle>
 		<classname>GZIPInputStream</classname>
 	</citetitle></ulink> is used to decompress it.</para>
		
		<para>The following example shows how to request a gzip compressed response from the server.</para>

		<programlisting language="java"><![CDATA[
// Add the gzip Accept-Encoding header
HttpHeaders requestHeaders = new HttpHeaders();
requestHeaders.setAcceptEncoding(ContentCodingType.GZIP);
HttpEntity<?> requestEntity = new HttpEntity<Object>(requestHeaders);

// Create a new RestTemplate instance
RestTemplate restTemplate = new RestTemplate();

// Make the HTTP GET request, marshaling the response to a String
ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, requestEntity, String.class);]]>
		</programlisting>
		
		<para>One thing to note, is that when using the J2SE facilities with the <classname>SimpleClientHttpRequestFactory</classname>, Gingerbread and newer automatically set the Accept-Encoding header to request gzip responses. This is built in functionality of newer versions of Android. If you desire to disable gzip, then you must set the <literal>identity</literal> value in the header.</para>

		<programlisting language="java"><![CDATA[
// Add the identity Accept-Encoding header
HttpHeaders requestHeaders = new HttpHeaders();
requestHeaders.setAcceptEncoding(ContentCodingType.IDENTITY);
HttpEntity<?> requestEntity = new HttpEntity<Object>(requestHeaders);

// Create a new RestTemplate instance
RestTemplate restTemplate = new RestTemplate();

// Make the HTTP GET request, marshaling the response to a String
ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, requestEntity, String.class);]]>
		</programlisting>

	</section>
  
	<section>
		
		<title>Retrieving JSON data via HTTP GET</title>
		
		<para>Suppose you have defined a Java object you wish to populate from a RESTful web request that returns JSON content. Marshaling JSON content requires Jackson or Gson to be available on the classpath.</para>
		
		<para>Define your object based on the JSON data being returned from the RESTful request:</para>
		
		<programlisting language="java"><![CDATA[
public class Event {

    private Long id;

    private String title;
	
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }
	
    public String setTitle(String title) {
        this.title = title;
    }
}]]>
		</programlisting>
		
		<para>Make the REST request:</para>
		
		<programlisting language="java"><![CDATA[
// Create a new RestTemplate instance
RestTemplate restTemplate = new RestTemplate();

// Make the HTTP GET request, marshaling the response from JSON to an array of Events
Event[] events = restTemplate.getForObject(url, Event[].class);]]>
		</programlisting>
		
		<para>You can also set the <literal>Accept</literal> header for the request:</para>
		
		<programlisting language="java"><![CDATA[
// Set the Accept header
HttpHeaders requestHeaders = new HttpHeaders();
requestHeaders.setAccept(Collections.singletonList(new MediaType("application","json")));
HttpEntity<?> requestEntity = new HttpEntity<Object>(requestHeaders);

// Create a new RestTemplate instance
RestTemplate restTemplate = new RestTemplate();

// Make the HTTP GET request, marshaling the response from JSON to an array of Events
ResponseEntity<Event[]> responseEntity = restTemplate.exchange(url, HttpMethod.GET, requestEntity, Event[].class);
Event[] events = responseEntity.getBody();]]>
		</programlisting>
		
	</section>
	
	<section>
		
		<title>Retrieving XML data via HTTP GET</title>
		
		<para>Using the same Java object we defined earlier, we can modify the requests to retrieve XML.</para>
		
		<para>Define your object based on the XML data being returned from the RESTful request. Note the annotations used by Simple to marshal the object:</para>
		
		<programlisting language="java"><![CDATA[
@Root
public class Event {

    @Element
    private Long id;

    @Element
    private String title;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public String setTitle(String title) {
        this.title = title;
    }
}]]>
		</programlisting>
		
		<para>To marshal an array of events from xml, you need to define a wrapper class for the list:</para>
		
		<programlisting language="java"><![CDATA[
@Root(name="events")
public class EventList {

   @ElementList(inline=true)
   private List<Event> events;

   public List<Event> getEvents() {
      return events;
   }

   public void setEvents(List<Event> events) {
       this.events = events;
   }
}]]>
		</programlisting>
		
		<para>Make the REST request:</para>
		
		<programlisting language="java"><![CDATA[
// Create a new RestTemplate instance
RestTemplate restTemplate = new RestTemplate();

// Make the HTTP GET request, marshaling the response from XML to an EventList object
EventList eventList = restTemplate.getForObject(url, EventList.class);]]>
		</programlisting>
		
		<para>You can also specify the <literal>Accept</literal> header for the request:</para>
		
		<programlisting language="java"><![CDATA[
// Set the Accept header
HttpHeaders requestHeaders = new HttpHeaders();
requestHeaders.setAccept(Collections.singletonList(new MediaType("application","xml")));
HttpEntity<?> requestEntity = new HttpEntity<Object>(requestHeaders);

// Create a new RestTemplate instance
RestTemplate restTemplate = new RestTemplate();

// Make the HTTP GET request, marshaling the response from XML to an EventList
ResponseEntity<EventList> responseEntity = restTemplate.exchange(url, HttpMethod.GET, requestEntity, EventList.class);
EventList eventList = responseEntity.getBody();]]>
		</programlisting>
		
	</section>
	
	<section>
		
		<title>Send JSON data via HTTP POST</title>
		
		<para>POST a Java object you have defined to a RESTful service that accepts JSON data.</para>
		
		<para>Define your object based on the JSON data expected by the RESTful request:</para>
		
		<programlisting language="java"><![CDATA[
public class Message 
{
    private long id;

    private String subject;

    private String text;

    public void setId(long id) {
        this.id = id;
    }

    public long getId() {
        return id;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public String getSubject() {
        return subject;
    }

    public void setText(String text) {
        this.text = text;
    }

    public String getText() {
        return text;
    }
}]]>
		</programlisting>
		
		<para>Make the REST request. In this example, the request responds with a string value:</para>
		
		<programlisting language="java"><![CDATA[
// Create and populate a simple object to be used in the request
Message message = new Message();
message.setId(555);
message.setSubject("test subject");
message.setText("test text");

// Create a new RestTemplate instance
RestTemplate restTemplate = new RestTemplate();

// Make the HTTP POST request, marshaling the request to JSON, and the response to a String
String response = restTemplate.postForObject(url, message, String.class);]]>
		</programlisting>
		
		<para>You can also specify the <literal>Content-Type</literal> header in your request:</para>
		
		<programlisting language="java"><![CDATA[
// Create and populate a simple object to be used in the request
Message message = new Message();
message.setId(555);
message.setSubject("test subject");
message.setText("test text");

// Set the Content-Type header
HttpHeaders requestHeaders = new HttpHeaders();
requestHeaders.setContentType(new MediaType("application","json"));
HttpEntity<Message> requestEntity = new HttpEntity<Message>(message, requestHeaders);

// Create a new RestTemplate instance
RestTemplate restTemplate = new RestTemplate();

// Make the HTTP POST request, marshaling the request to JSON, and the response to a String
ResponseEntity<String> responseEntity = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);
String result = responseEntity.getBody();]]>
		</programlisting>
	</section>
	
	<section>
		
		<title>HTTP Basic Authentication</title>
		
		<para>This example illustrates how to populate the <ulink url="http://www.w3.org/Protocols/HTTP/1.0/draft-ietf-http-spec.html#BasicAA">
 	<citetitle>HTTP Basic Authentication</citetitle></ulink> header with the username and password. If the username and password are accepted, then you will receive the response from the request. If they are not accepted, then the server is supposed to return an <ulink url="http://www.w3.org/Protocols/HTTP/1.0/draft-ietf-http-spec.html#Code401">
 	<citetitle>HTTP 401 Unauthorized</citetitle></ulink> response. Internally, RestTemplate handles the response, then throws an <classname>HttpClientErrorException</classname>. By calling <methodname>getStatusCode()</methodname> on this exception, you can determine the exact cause and handle it appropriately.</para>
		
		<programlisting language="java"><![CDATA[
// Set the username and password for creating a Basic Auth request
HttpAuthentication authHeader = new HttpBasicAuthentication(username, password);
HttpHeaders requestHeaders = new HttpHeaders();
requestHeaders.setAuthorization(authHeader);
HttpEntity<?> requestEntity = new HttpEntity<Object>(requestHeaders);

// Create a new RestTemplate instance
RestTemplate restTemplate = new RestTemplate();

try {
    // Make the HTTP GET request to the Basic Auth protected URL
    ResponseEntity<Message> response = restTemplate.exchange(url, HttpMethod.GET, requestEntity, String.class);
    return response.getBody();
} catch (HttpClientErrorException e) {
    Log.e(TAG, e.getLocalizedMessage(), e);
    // Handle 401 Unauthorized response
}]]>
		</programlisting>
	
	</section>
	
  </section>

</chapter>
